#version 450
layout(local_size_x = 4, local_size_y = 4, local_size_z = 1) in;

// Input: BC4 blocks in r8
layout(binding = 0) readonly buffer SrcBC { uint data[]; } srcBC;
// Output: RGBA8
layout(binding = 1, rgba8) uniform writeonly image2D dstImage;

layout(push_constant) uniform Push {
    uvec2 extent; // texel extent
    uint blocksPerRow;
    uint pad;
} pc;

#include "bc_common.glsl"

void main() {
    uvec2 gid = gl_GlobalInvocationID.xy;
    if (gid.x >= pc.extent.x || gid.y >= pc.extent.y) return;

    // Compute block index and local pixel
    uvec2 block = gid / uvec2(4,4);
    uvec2 local = gid % uvec2(4,4);
    uint blockIndex = block.y * pc.blocksPerRow + block.x;

    // BC4 block layout: r0, r1, 48-bit indices
    uint base = blockIndex * 4u; // 16 bytes per block / 4 bytes per uint
    uint r0 = srcBC.data[base + 0] & 0xFFu;
    uint r1 = (srcBC.data[base + 0] >> 8) & 0xFFu;
    uvec2 bits = uvec2(srcBC.data[base + 2], srcBC.data[base + 1]);

    uint pal[8];
    bc4_palette(r0, r1, pal);

    uint linear = local.y * 4u + local.x;
    uint idx = bc3bit_index(bits, int(linear));
    uint r = pal[idx];
    vec4 outc = vec4(r / 255.0, r / 255.0, r / 255.0, 1.0);
    imageStore(dstImage, ivec2(gid), outc);
}


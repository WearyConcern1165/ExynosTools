#include "logging.h"
#include "bc_emulate.h"
#include <string.h>

// Embedded SPIR-V headers generated by CMake (xxd -i)
#ifdef __has_include
#  if __has_include("bc4_spv.h")
#    include "bc4_spv.h"
#  endif
#  if __has_include("bc5_spv.h")
#    include "bc5_spv.h"
#  endif
#endif

typedef struct XenoBCPipeline {
    VkPipeline pipeline;
} XenoBCPipeline;

struct XenoBCContext {
    VkDevice device;
    VkPipelineCache pipeline_cache;
    VkDescriptorSetLayout desc_layout;
    VkPipelineLayout pipeline_layout;
    XenoBCPipeline bc4;
    XenoBCPipeline bc5;
};

static VkResult create_shader_module(VkDevice device, const uint32_t* code, size_t bytes, VkShaderModule* out) {
    VkShaderModuleCreateInfo ci = {0};
    ci.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    ci.codeSize = bytes;
    ci.pCode = code;
    return vkCreateShaderModule(device, &ci, NULL, out);
}

static VkResult create_compute_pipeline(VkDevice device, VkPipelineLayout layout, VkShaderModule smod, VkPipeline* out) {
    VkPipelineShaderStageCreateInfo stage = {0};
    stage.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    stage.stage = VK_SHADER_STAGE_COMPUTE_BIT;
    stage.module = smod;
    stage.pName = "main";

    VkComputePipelineCreateInfo ci = {0};
    ci.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
    ci.stage = stage;
    ci.layout = layout;
    return vkCreateComputePipelines(device, VK_NULL_HANDLE, 1, &ci, NULL, out);
}

XenoBCContext* xeno_bc_create_context(VkDevice device, VkPhysicalDevice phys) {
    (void)phys;
    XenoBCContext* ctx = (XenoBCContext*)calloc(1, sizeof(XenoBCContext));
    ctx->device = device;

    VkPipelineCacheCreateInfo pcci = {0};
    pcci.sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
    if (vkCreatePipelineCache(device, &pcci, NULL, &ctx->pipeline_cache) != VK_SUCCESS) {
        XENO_LOGE("bc_emulate: failed to create pipeline cache");
        free(ctx);
        return NULL;
    }

    VkDescriptorSetLayoutBinding bindings[2];
    memset(bindings, 0, sizeof(bindings));
    bindings[0].binding = 0; // Src buffer
    bindings[0].descriptorCount = 1;
    bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
    bindings[0].stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
    bindings[1].binding = 1; // Dst image
    bindings[1].descriptorCount = 1;
    bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
    bindings[1].stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;

    VkDescriptorSetLayoutCreateInfo dlci = {0};
    dlci.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    dlci.bindingCount = 2;
    dlci.pBindings = bindings;
    if (vkCreateDescriptorSetLayout(device, &dlci, NULL, &ctx->desc_layout) != VK_SUCCESS) {
        XENO_LOGE("bc_emulate: failed to create descriptor set layout");
        vkDestroyPipelineCache(device, ctx->pipeline_cache, NULL);
        free(ctx);
        return NULL;
    }

    VkPushConstantRange pcr;
    pcr.stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
    pcr.offset = 0;
    pcr.size = sizeof(uint32_t) * 4;

    VkPipelineLayoutCreateInfo plci = {0};
    plci.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    plci.setLayoutCount = 1;
    plci.pSetLayouts = &ctx->desc_layout;
    plci.pushConstantRangeCount = 1;
    plci.pPushConstantRanges = &pcr;
    if (vkCreatePipelineLayout(device, &plci, NULL, &ctx->pipeline_layout) != VK_SUCCESS) {
        XENO_LOGE("bc_emulate: failed to create pipeline layout");
        vkDestroyDescriptorSetLayout(device, ctx->desc_layout, NULL);
        vkDestroyPipelineCache(device, ctx->pipeline_cache, NULL);
        free(ctx);
        return NULL;
    }

#ifdef bc4_spv_len
    {
        VkShaderModule smod;
        if (create_shader_module(device, (const uint32_t*)bc4_spv, bc4_spv_len, &smod) == VK_SUCCESS) {
            if (create_compute_pipeline(device, ctx->pipeline_layout, smod, &ctx->bc4.pipeline) != VK_SUCCESS) {
                XENO_LOGE("bc_emulate: failed to create BC4 pipeline");
            }
            vkDestroyShaderModule(device, smod, NULL);
        } else {
            XENO_LOGE("bc_emulate: failed to create shader module for BC4");
        }
    }
#endif

#ifdef bc5_spv_len
    {
        VkShaderModule smod;
        if (create_shader_module(device, (const uint32_t*)bc5_spv, bc5_spv_len, &smod) == VK_SUCCESS) {
            if (create_compute_pipeline(device, ctx->pipeline_layout, smod, &ctx->bc5.pipeline) != VK_SUCCESS) {
                XENO_LOGE("bc_emulate: failed to create BC5 pipeline");
            }
            vkDestroyShaderModule(device, smod, NULL);
        } else {
            XENO_LOGE("bc_emulate: failed to create shader module for BC5");
        }
    }
#endif

    XENO_LOGI("bc_emulate: context initialized");
    return ctx;
}

void xeno_bc_destroy_context(XenoBCContext* ctx) {
    free(ctx);
}

VkResult xeno_bc_decode_image(VkCommandBuffer cmd,
                              XenoBCContext* ctx,
                              VkImage src_bc, VkImage dst_rgba,
                              XenoBCFormat format,
                              VkExtent3D extent) {
    (void)src_bc;
    if (!ctx) return VK_ERROR_INITIALIZATION_FAILED;

    // Transition dst to GENERAL (simplified; application is expected to manage its own barriers too)
    VkImageMemoryBarrier2 barrier = {0};
    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2;
    barrier.dstStageMask = VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT;
    barrier.dstAccessMask = VK_ACCESS_2_SHADER_WRITE_BIT;
    barrier.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    barrier.newLayout = VK_IMAGE_LAYOUT_GENERAL;
    barrier.image = dst_rgba;
    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    barrier.subresourceRange.levelCount = VK_REMAINING_MIP_LEVELS;
    barrier.subresourceRange.layerCount = VK_REMAINING_ARRAY_LAYERS;

    VkDependencyInfo dep = {0};
    dep.sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO;
    dep.imageMemoryBarrierCount = 1;
    dep.pImageMemoryBarriers = &barrier;

    vkCmdPipelineBarrier2(cmd, &dep);

    VkPipeline pipeline = VK_NULL_HANDLE;
    switch (format) {
        case XENO_BC4: pipeline = ctx->bc4.pipeline; break;
        case XENO_BC5: pipeline = ctx->bc5.pipeline; break;
        default: return VK_ERROR_FEATURE_NOT_PRESENT;
    }
    vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_COMPUTE, pipeline);

    // Push constants: extent.x, extent.y, blocksPerRow, pad
    uint32_t pc[4] = { extent.width, extent.height, (extent.width + 3) / 4, 0 };
    vkCmdPushConstants(cmd, ctx->pipeline_layout, VK_SHADER_STAGE_COMPUTE_BIT, 0, sizeof(pc), pc);

    // Dispatch groups of 4x4
    uint32_t gx = (extent.width + 3) / 4;
    uint32_t gy = (extent.height + 3) / 4;
    vkCmdDispatch(cmd, gx, gy, extent.depth);

    // Transition dst to SHADER_READ_ONLY_OPTIMAL for subsequent sampling
    VkImageMemoryBarrier2 post = {0};
    post.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2;
    post.srcStageMask = VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT;
    post.srcAccessMask = VK_ACCESS_2_SHADER_WRITE_BIT;
    post.oldLayout = VK_IMAGE_LAYOUT_GENERAL;
    post.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    post.image = dst_rgba;
    post.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    post.subresourceRange.levelCount = VK_REMAINING_MIP_LEVELS;
    post.subresourceRange.layerCount = VK_REMAINING_ARRAY_LAYERS;

    VkDependencyInfo dep2 = {0};
    dep2.sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO;
    dep2.imageMemoryBarrierCount = 1;
    dep2.pImageMemoryBarriers = &post;
    vkCmdPipelineBarrier2(cmd, &dep2);

    return VK_SUCCESS;
}

